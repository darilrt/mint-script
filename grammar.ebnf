(* Statements *)
program = {import}, { statement }, export;
statement = ( block 
    | if
    | while
    | foreach
    | return
    | break
    | continue
    | var_decl
    | var_assign
    | class
    | trait
    | function
    | expr_statement
    ), ('\n', '\0');

block = '{', { statement }, '}';
if = 'if', expression, block, [ 'else', block ];
while = 'while', expression, block;
foreach = 'for', ident, 'in', expression, block;
return = 'return', [ expression ];
break = 'break';
continue = 'continue';
expr_statement = expression;

(* Imports *)
import = 'import', (module_access | [module_list, 'from', string ]);
module_access = module_name, ('.', ( '*' | ident ) | module_list );
module_name = ident, { '.', ident };
module_list = '{', ident_list, '}';

(* Exports *)
export = 'export', '{', export_list, '}';
export_list = export_item, { ',', export_item };
export_item = ident, [ 'as', ident ];

(* Functions *)
function = ident, '::', 'fn', [ '[', generic_list, ']' ], '(', [ param_list ], ')', [ '->', type ], block;
param_list = param, { ',', param };
param = ident, ':', type;

(* Classes *)
class = ident, '::', 'class', [ '[', generic_list, ']' ], [ '(' ident_list ')' ], block;
ident_list = ident, { ',', ident };

(* Traits *)
trait = ident, '::', 'trait', [ '[', generic_list, ']' ], block;

(* Variables *)
var_decl = ident, ( [ ':', type ], [ '=', expression ] | ':=', expression );
var_assign = ident, '=', expression;

(* Types *)
type_list = type, { ',', type }; (* Implemented *)
type = list_type; (* Implemented *)
list_type = '[]', ['?'], optional_type | optional_type; (* Implemented *)
optional_type = dotted_type, ['?']; (* Implemented *)
dotted_type = generic_type, { '.', generic_type }; (* Implemented *)
generic_type = ident, [ '[', type_list, ']' ]; (* Implemented *)

generic_list = generic_pair, { ',', generic_pair };
generic_pair = ident, ':', generic_value;
generic_value = (type, { '+', type });

(* Expressions *)
expression = logical_and; (* Implemented *)
expr_list = expression, { ',', expression }; (* Implemented *)
logical_and = logical_or, ( '&&', logical_and ); (* Implemented *)
logical_or = bitwaise_or, ( '||', logical_or ); (* Implemented *)
bitwaise_or = bitwaise_xor, ( '|', bitwaise_or ); (* Implemented *)
bitwaise_xor = bitwaise_and, ( '^', bitwaise_xor ); (* Implemented *)
bitwaise_and = comparison, ( '&', bitwaise_and ); (* Implemented *)
comparison = shift, ( ( '==' | '!=' | '<' | '>' | '<=' | '>=' ), shift ); (* Implemented *)
shift = additive, ( ( '<<' | '>>' ), shift ); (* Implemented *)
additive = multiplicative, ( ( '+' | '-' ), additive ); (* Implemented *)
multiplicative = unary, ( ( '*' | '/' | '%' ), multiplicative ); (* Implemented *)
unary = ( '!' | '~' | '-' | '+' | '++' | '--' ), unary | postfix; (* Implemented *)
postfix = instancing, ( '++' | '--' | 'as', type ); (* Implemented *)
instancing = postfix_access, [ struct_brace_initilizer ]; (* Implemented *)
postfix_access = factor, { ( '.', ident ) | ( '(', expr_list, ')' | '[', ( expression | type_list ), ']' ) }; (* Implemented *)
factor = literal | '(', expression, ')'; (* Implemented *)
literal = integer | float | string | 'true' | 'false' | 'null' | ident | array | dict; (* Implemented *)
array = '[', expr_list, ']'; (* Implemented *)
dict = '{', ( dict_pair, { ',', dict_pair } ), '}'; (* Implemented *)
dict_pair = expression, ':', expression;  (* Implemented *)
struct_brace_initilizer = '{', ( struct_pair, { ',', struct_pair } ), '}'; (* Implemented *)
struct_pair = '.', ident, '=', expression; (* Implemented *)

(* Literals *)
integer = ( '0' | [1-9], { [0-9] } ), [ 'u' | 'U' | 'l' | 'L' ];
float = ( [0-9], { [0-9] } ), '.', [0-9], { [0-9] }, [ 'f' | 'F' | 'd' | 'D' ];
string = '"', { ( '\\' | '\n' | '\r' | '\t' | '\b' | '\f' | '\v' | '\0' | [^"\n\r] ) }, '"';
ident = [a-zA-Z_], { [a-zA-Z0-9_] };

(* Tokens *)
comment = '/*', { [^*] }, '*/' | '//', { [^\n] }, '\n';
whitespace = [ \t\r\n\v\f]+;
symbol = [][{}():;,.?@&|~^%*/+-];